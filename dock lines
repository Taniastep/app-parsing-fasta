import pandas as pd
def clo():
    ict = dict()
    with open(r'C:\Users\Student\Desktop\thevv1\app_parsing_directory_and_csv\mature.fa','r') as f:
      for line in f:
         m = line.strip()
         if len(m) != 0 and m[0] == '>':
           m = m.split()
           key = m[0][1:]
           ict[key] = ""
         else:
           ict[key] += m

      for key, value in ict.items():
         print(key, '*', value)
    return ict
"""""
  Принцип работы заголовка
Заголовком считается первая строка, начинающаяся с символа >.
Каждая такая строка интерпретируется как начало нового блока данных, который будет храниться в словаре ict
  Как рабоотает функция clo()
Читает файл mature.fa.
Собирает данные в словарь, где ключи — это заголовки, а значения — последовательности строк, следующих за каждым заголовком.
Выводит собранные данные на экран.
Сохраняет результаты в CSV-файл.
  Результат
Результат возвращается в виде словаря.

Функция читает файл mature.fa и создает словарь, где ключом является первая строка после символа '>',
а значением — последовательность символов до следующей строки, начинающейся с '>'. :return: Словарь с последовательностями :rtype: dict
"""""
def mat(ict):
    matrix = []
    for key, value in ict.items():
        g = value.count('G')
        c = value.count('C')
        k = (g + c) / len(value)
        gc = round(k, 4)
        row = [key, gc, *list(value)]
        matrix.append(row)
    return matrix
"""""
Как работает
Функция matrix() проходит по каждому элементу словаря ict.
Подсчитывает количество нуклеотидов 'G' и 'C'.
Рассчитывает долю GC-содержания для каждой последовательности.
Формирует новую матрицу, где каждая строка представляет собой ключ, долю GC и саму последовательность.
Результат
Матрица возвращается как результат выполнения функции.
"""""

def poe(matrix):
    df = pd.DataFrame(matrix)
    return df

"""""
Функция преобразует список списков в DataFrame Pandas. 
"""""


def itt(df):
    aaa = []
    ttt = []
    ccc = []
    ggg = []
    for i in range(2, len(df.columns)):
        aa, tt, gg, cc, gap = 0, 0, 0, 0, 0
        st = list(df.iloc[:, i])
        aa += st.count('A')
        tt += st.count('T')
        cc += st.count('C')
        gg += st.count('G')
        gap += st.count('-')
        if gap / df.shape[0] < 0.5:
            aaa.append(aa / df.shape[0])
            ttt.append(tt / df.shape[0])
            ccc.append(cc / df.shape[0])
            ggg.append(gg / df.shape[0])
    print(aaa)
    print(ttt)
    print(ccc)
    print(ggg)
"""""
Функция рассчитывает количество A, T, C, G в каждом столбце DataFrame, исключая столбцы, где доля пропусков '-' больше 50%. 
Ничего не возвращает, выводит результаты в консоль :rtype: None 
"""""

gtre = itt(poe(mat(clo())))
"""""
Последовательность выполнения функций
"""""

from json import *
with open('sample.json', 'w') as fp:
    dump(clo(), fp)
"""""
Сохранение результата работы функции clo() в JSON-файл

"""""

def cvv():
    """""
    Читает указанный файл, находит ключевые блоки данных ("Alignment:", "Query:"), обрабатывает строки внутри этих блоков и возвращает массив структурированных данных. 
    Возращает матрицу, содержащую обработанные строки файла.
    """""
    
    """
    Переменная для хранения промежуточных результатов
    """
    Alignment_and_Query = []
    Line_number = 0
    matrix1 = []
    """"" Буферная переменная для временных данных """""
    row = []
    with open(r'C:\Users\Tania\AppData\Roaming\JetBrains\PyCharmCE2023.3\scratches\CALM2P2_Callithrix_12.txt', 'r') as file:
        sas = file.readlines()
        cleaned_file = [line.strip() for line in sas]
        
        """"" 
        Обработка строк для нахождения номеров нужных блоков
        """""
        for line in sas:
            Line_number += 1
            if line.startswith("  Alignment:"):
                Alignment1 = Line_number + 1
                Alignment = Line_number
            
            if line.startswith("Query:"):
                Query = Line_number - 1
                
        s = cleaned_file[Alignment1 - 4]
        d = s.split()
        end = int(d[5])
        
        """""
        Цикл обработки данных между блоками "Alignment:" и "Query:"
        """""
        for i in range(0, len(sas) - Alignment1, 5):
            split_Alignment = cleaned_file[Alignment1 + i].split()
            row = [
                split_Alignment[2],   # Значение поля №2
                split_Alignment[1],   # Значение поля №1
                split_Alignment[3]    # Значение поля №3
            ]
            matrix1.append(row)
            
            a = int(split_Alignment[3])
            
            if a != end:
                continue
            
            split_Alignment = cleaned_file[Alignment1 + i + 2].split()
            row = [
                split_Alignment[2],
                split_Alignment[1],
                split_Alignment[3]
            ]
            matrix1.append(row)
            
            if a == end:
                break
        
        """""
        Сохраняем последнюю найденную строку из блока "Query:" и "Alignment:"
        """""
        Alignment_and_Query.append(cleaned_file[Query])
        Alignment_and_Query.append(cleaned_file[Alignment])
        print(Alignment_and_Query)
    
    return matrix1


def gvv(matrix1):
    """
    Получив на входе структуру данных от `cvv`, преобразует её в объект типа `pandas.DataFrame` и записывает этот DataFrame в CSV-файл.
    Входные данные матрица.
    Функция ничего не возращает
    """
    df1 = pd.DataFrame(matrix1)
    csv_path = r'C:\Users\Tania\AppData\Roaming\JetBrains\PyCharmCE2023.3\scratches\df1_csv'
    df1.to_csv(csv_path, index=False)
    print(df1)

ghhh = gvv(cvv())
"""""
Основной вызов функций (ghhh = gvv(cvv())`) объединяет обе функции последовательно — сначала считываются и обрабатываются данные из файла, затем создается и сохраняется таблица.
"""""
